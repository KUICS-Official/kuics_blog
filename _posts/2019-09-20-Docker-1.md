---
title: Docker 1
published: true
---

# Docker 1
## Chapter 0 환경
Ubuntu 18.04 LTS

>하지만 윈도우와 맥 환경에서도 동작할 것 입니다.

## Chapter 1 도커란?
### 1. 도커를 설치하기
도커는 크로스 플랫폼입니다. 따라서 도커는 리눅스, 윈도우, 맥 모두에서 작동합니다.<br/>
https://docs.docker.com 에서는 각 OS에 따른 도커 설치가이드를 제공하고 있습니다.
>윈도우에서는 가상화 기술을 허용됨으로 바꾸어 줘야합니다. BIOS에서 VT-x를 허용됨 상태로 바꾸세요.

도커를 설치한 후에 쉘을 켜주세요. (윈도우의 경우에는 cmd, powershell 모두 가능합니다.)<br/>
도커를 설치한 후에 ```docker version``` 명령어를 실행시켜면 아래와 같은 결과를 볼 수 있을 것입니다.
![Result of docker version](/blog/_src/docker_version.png?raw=true)

### 2. 컨테이너를 실행시키기
도커이미지는 패키지되어 있는 응용프로그램입니다. 이 이미지는 Github를 사용하는 것과 마찬가지로 Push, Pull 할 수 있습니다. 이미지는 응용프로그램 패키지(e.g. nginx, mariadb, etc.)를 저장하는 단위입니다. 응용프로그램을 시작하기 위해서는 먼저 이미지를 이용해 컨테이너를 실행시켜야 합니다.<br/>
이미지는 일반적으로 단일 프로세스를 실행시키기 위해서 만들어 집니다. 만들고자 하는 응용프로그램이 다른 서비스와 함께 작동해야 한다면 컨테이너를 이용해 함께 작동하도록 할 수 있습니다. 이는 Chapter 5에서 다룰 것 입니다.<br/>
이미지를 이용해 컨테이너를 실행시킬 때, 응용프로그램은 잠깐만 작동하고 꺼질 수도 있고, 백그라운드 프로세스처럼 오랬동안 작동할 수도 있습니다. 또한, 실제 컴퓨터와 같이 상호작용가능할 수도 있습니다.

### 3. Hello World
가장 단순한 컨테이너부터 실행시켜 보겠습니다. 도커가 설치되어 있고 인터넷에 연결되어 있다면 ```docker container run hello-world```는 명령어를 실행시킬 수 있을 것입니다. 결과는 아래와 같을 것입니다.

> 대부분 도커 명령어는 container를 생략한 명령어(e.g. ```docker run hello-world```)로도 동작할 것입니다. 다만 container를 생략하지 않는 것이 바람직합니다.

![Result of docker container run hello-world](/blog/_src/docker_container_run_hello-world.png?raw=true)<br/><br/>
결과는 단순해보이지만 컨테이너를 실행시킬때 많은 일들이 일어납니다.
* 로컬 도커 클라이언트가 도커 서버에 hello-world라는 이름의 컨테이너를 실행시키라는 요청을 보냅니다.
* 도커 서버는 요청받은 이미지가 캐시되어 있는지 확인합니다. 캐시되어 있지 않다면 도커 허브에서 이미지를 다운로드 받습니다.
* 이미지가 로컬에 다운받아지면 도커 서버는 이미지를 이용해 컨테이너를 실행시킵니다. 또한, 출력을 도커 클라이언트로 전달합니다.

이 이미지에서 컨테이너 내부의 프로세스는 콘솔에 출력을 한 후에 끝납니다. 컨테이너는 내부에서 동작 중인 프로세스가 없으므로 컨테이너에서 나가게 됩니다. 이를 현재 실행 중인 컨테이너의 목록을 확인하는 명령어인 ```docker container ls```를 이용해 확인할 수 있습니다. 아래에서 보이다시피 hello-world 컨테이너는 동작을 멈추었으므로 목록에 나타나지 않습니다.
![Result of container ls](/blog/_src/docker_container_ls.png?raw=true)
>```docker container ls --all```명령어를 사용하면 실행 중이지 않은 컨테이너도 확인할 수 있습니다.

이러한 실행 후에 실행을 멈추는 형태의 컨테이너는 상당히 유용합니다. 이러한 컨테이너는 백업과 같은 반복적인 작업에 사용될 수 있습니다. 하지만, 전에 언급했다시피 컨테이너는 오래동안 작동하는 백그라운드 프로세스으로도 잘 작동합니다.

### 4. Hello Nginx
Nginx는 가볍고, 강력한 오픈소스 HTTP 서버입니다. Nginx는 설정하기 쉽고, 용량이 작기 때문에 컨테이너로 사용하기에 적절합니다.<br/>
도커 허브에는 Nginx팀에서 공식적으로 지원하는 [공식 Nginx이미지](https://hub.docker.com/_/nginx/)가 있습니다. ```docker container run nginx:alpine```명령어를 이용하면 Alpine 리눅스를 이용하는 Nginx 도커 이미지의 가장 작은 버전을 실행시킬 수 있습니다.
![Result of docker container run nginx:alpine](/blog/_src/docker_container_run_nginx_alpine.png?raw=true)<br/><br/>
이미지를 실행시키면 컨테이너는 포그라운드에서 실행되고 터미널에서 Nginx 프로세스를 실행시킵니다. 따라서 아무런 커맨드도 칠 수 없습니다. 컨테이너는 80번 포트로 수신 대기 중입니다. 하지만 이 80번 포트는 컨테이너 내부의 포트입니다. 따라서 우리는 호스트에서 접근할 수 없습니다. Ctrl+C를 눌러 프로세스를 종료하겠습니다.<br/>
도커는 장시간 작동하는 웹서버같은 백그라운드 프로세스도 detach 모드를 이용해 지원합니다. 컨테이너가 detach 모드에서 동작하면 백그라운드에서 동작하게 됩니다. --detach 옵션을 이용해 컨테이너를 백그라운드에서 동작시키고, --publish 옵션을 이용해 80번 포트를 연결하겠습니다. 전체 명령어는 ```docker container run --detach --publish 80:80 nginx:alpine``` 입니다. 
![Result of docker container run --detach --publish 80:80 nginx:alpine](/blog/_src/docker_container_run_--detach.png?raw=true)<br/><br/>
--publish 80:80은 내부의 80번 포트와 외부의 80번 포트를 연결하겠다는 의미입니다. 포트는 공유되지 않으므로 다른 80번 포트를 사용하는 프로세스는 실행시킬 수 없습니다. 하지만, 컨테이너와 호스트의 포트 연결은 자유롭게 선택할 수 있습니다. 예를 들어, --publish 8081:80은 컨테이너의 80번 포트를 호스트의 8081번 포트로 연결시킵니다.<br/>
도커의 출력은 새로 만들어진 컨테이너의 ID를 출력한 뒤 터미널이 다시 제어할 수 있도록 만들어 줍니다. ```docker container ls```명령어를 사용하면 방금 만든 컨테이너가 작동 중임을 확인할 수 있습니다.
![Result of docker container ls](/blog/_src/docker_container_ls_nginx.png?raw=true) <br/><br/>
이 결과는 컨테이너가 실행 중인 이미지, 컨테이너의 축약된 ID(여기서는 c5671c6a444e), 컨테이너의 이름(여기서는 zealous_almeida), 컨테이너에서 실행 중인 명령어(nginx -g 'daemon of ...)등의 정보를 보여줍니다. 이 컨테이너는 내부와 외부의 80번 포트가 연결된 채로 백그라운드에서 동작 중이기 때문에 호스트에서 80번 포트로 연결을 시도하면 컨테이너로 연결됩니다. 따라서 호스트에서 80번 포트로 연결하면 컨테이너 내부의 Nginx 프로세스로부터 응답을 받아오게 됩니다. 따라서 웹브라우저에서 http://localhost 에 접근하게 되면 아래와 같은 화면을 볼 수 있습니다.
![Result of localhost](/blog/_src/localhost_result_1.png?raw=true)<br/><br/>
>Docker Toolbox를 사용하는 오래된 버전의 윈도우와 맥은 도커가 리눅스 가상머신에서 동작하므로 자신의 IP를 따로 갖고 있습니다. 따라서 localhost가 아닌 ```docker-machine ip```명령어를 이용해 도커의 IP를 확인하여 그 IP로 접근해야 합니다.

도커는 장기간 작동하는 백그라운드 프로세스를 실행시키기에 이상적인 플랫폼입니다. 컨테이너 내에서 작동하는 Nginx 웹서버는 누군가가 접속 중이 아니라면 매우 적은 자원을 요구합니다.<br/>
도커에서는 수백개의 백그라운드 컨테이너를 이러한 방식으로 실행시킬 수 있습니다. 대부분의 경우 모든 컨테이너가 항상 많이 사용되는 것이 아니므로 호스트는 무리없이 수백개의 컨테이너를 실행시킬 수 있습니다.

### 5. Hello Ubuntu
컨테이너는 상호작용 가능한 형태로도 실행시킬 수 있습니다. 컨테이너는 도커 CLI에 연결되어있는 동안 실행되며, 이는 원격 접속과 비슷합니다. 이러한 형태의 컨테이너는 이미지를 체크하거나 이미지를 도구로서 활용할 때, 이미지를 자신의 이미지를 만들기 위해 사용할때 활용됩니다.<br/>
대부분의 도커 허브 이미지는 리눅스를 기초 OS로 사용하며, 그 중에서도 우분투는 가장 유명한 기초 이미지입니다. 캐노니컬은 공식 우분투 이미지를 제공하며, 도커 허브를 출시 일정과 통합시켰습니다. 따라서 최신 우분투는 ```docker container run --interactive --tty ubuntu:latest```명령어를 이용해 도커 허브에서 다운받을 수 있습니다.
![Result of docker container run --interactive --tty ubuntu:latest](/blog/_src/docker_run_it_ubuntu.png?raw=true)<br/><br/>
--interactive와 --tty 옵션(주로 -it로 줄여씁니다.)을 이용하면 도커가 터미널 에뮬레이션을 이용해 컨테이너를 상호작용 가능하도록 실행시킵니다. 이러한 컨테이너는 사용자가 컨테이너를 나가기 전까지 실행됩니다. 또한 ```docker container run --interactive --tty ubuntu:18.04```와 같이 버전을 명시할 수도 있습니다.<br/>
하지만 이 이미지를 사용하다보면 진짜 우분투와는 다르게 동작함을 알 수 있습니다. 도커의 우분투는 작은 용량을 위해 우분투 서버에서도 일부분만을 사용합니다. 다시말해서, 대부분의 기본 유틸리티들을 사용할 수 없습니다. 파일을 수정하기 위해 일반적인 우분투에는 기본적으로 Nano 텍스트 에디터가 깔려있지만 이 우분투에는 설치되어 있지 않습니다. 또한, Nano 텍스트 에디터를 설치를 시도해보면 이미지의 소프트웨어  라이브러리들이 최신 버전이 아님을 알 수 있습니다.
![Result of nano and nano install](/blog/_src/docker_ubuntu_nano.png?raw=true)<br/><br/>
하지만 우리는 이 우분투도 다른 우분투와 똑같이 사용할 수 있습니다. 따라서 ```apt-get update```명령어를 이용해 레포지토리를 업데이트할 수 있습니다. 하지만 이것은 이미지에는 영향을 미치지 못합니다. ```exit```명령어를 실행시키면 컨테이너는 멈추게 됩니다. 하지만 업데이트는 이미지에는 적용되지 않습니다. 다음에 다시 우분투 이미지를 이용해 컨테이너를 실행시키면, 업데이트 이전의 우분투 이미지일 것 입니다.<br/>
도커 허브에서는 Ubuntu, Alpine, BusyBox와 같은 유명한 기초 이미지를 제공합니다. 하지만 이러한 이미지는 최소화된 버전입니다. 더 적은 소프트웨어는 이미지를 작게 만들며 또한 이는 공격 벡터의 개수를 줄입니다. 컨테이너는 가상머신 또는 실제 서버와 다릅니다. 일반적으로 컨테이너는 OS 패치나 오류수정을 위해 업데이트하지 않습니다. 컨테이너는 빌드와 실행에 적은 자원을 요구하므로 업데이트를 하는 것보다는 새로운 컨테이너를 만들게 됩니다.

***
이 내용은 Docker_Succintly책을 기반으로 쓰여졌습니다. 이 책은 https://www.syncfusion.com/ebooks 에서 다운로드 받을 수 있습니다.