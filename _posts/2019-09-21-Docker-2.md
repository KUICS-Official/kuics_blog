---
title: Docker 2
published: true
---

## Chapter 2  도커로 응용프로그램을 패키징하기
### 1. 도커파일이란?
자신만의 도커이미지를 패키지하기 위해서는 도커파일이라는 텍스트파일을 작성해야합니다. 도커파일에는 이미지를 만들기 위한 모든 단계가 써있습니다. 도커파일은 단순하고 제한된 영역에만 사용되는 문법을 사용합니다. 아래의 코드는 단순한 형태의 도커파일입니다.
```
FROM ubuntu
RUN apt-get update && apt-get install nano
```
이 명령어를 Dockerfile이라는 이름의 파일을 만든 뒤 그 안에 쓰면 됩니다. 이 도커파일으로 이미지를 빌드하고 그 이미지를 이용해 컨테이너를 실행시키면 nano 패키지가 깔려있는 우분투 컨테이너를 사용할 수 있게 됩니다. ```FROM``` 명령어는 기초이미지를 지정합니다. 이 기초이미지로부터 이후의 도커파일의 내용을 이용해 변화가 일어나게 됩니다. 이 경우에는 nano를 설치하기 위한 두 개의 ```apt```명령어입니다.<br/>
이미지를 빌드하기 위해서 ```docker image build``` 명령어를 이용해야 합니다. 이 명령어를 실행시킬 때 이미지를 구분하기 위한 레포지토리 이름과 도커가 이미지를 빌드하기 위해 사용할 도커파일의 위치를 적어줘야 합니다. 또한 이미지를 라벨은 이용해 태그할 수 있습니다. 따라서 우리는 한 레포지토리에서 동시에 여러 버전의 이미지를 사용할 수 있습니다.(e.g. ```ubuntu:16.04```와 ```ubuntu:18.04 ```)```docker image build --tag kuicsofficial/ubuntu-with-nano .```명령어를 사용하면 현재 디렉토리에 있는 도커파일을 사용하여 이미지를 빌드합니다.
![Result of docker image build --tag kuicsofficial/ubuntu-with-nano](/blog/assets/2019-09-21-Docker-2/docker_image_build_ubuntu-with-nano_1.png)<br/><br/>
>Dockerfile은 따로 옵션을 주지 않았을 때의 기본 이름입니다. --file 옵션을 이용하면 임의의 이름의 파일을 이미지 빌드를 위한 도커파일로 사용할 수 있습니다. 예를 들어 server.dockerfile을 이미지 빌드를 위한 도커파일로 사용하고 싶다면 ```docker image build --file server.dockerfile```명령어를 사용하면 됩니다.

```image build```명령어는  도커 서버에서 실행됩니다.(클라이언트는 단순히 정보를 전달하는 역할만을 수행합니다.) 따라서 도커파일의 위치를 명시해주어야 합니다.(여기서는 현재 폴더에 도커파일이 있으므로 .을 사용합니다.) 클라이언트는 서버에 현재 폴더의 내용을 전달하고, 서버는 이미지를 빌드할 때 사용될 폴더에 그 내용을 저장합니다. 나중에 다시 살펴보겠지만, 이 폴더를 'build context'라고 부릅니다.<br/>
이미지를 빌드할 때 레포지토리 이름을 인자로 전달할 수 있습니다. 이미지를 로컬에서 빌드할 때 원하는 이름은 무엇이든 정할 수 있지만, 일반적으로 ```{user}/{application}```형식을 사용합니다. 여기서 ```{user}```는 도커허브의 ID입니다.<br/>
태그는 이미지를 구분가능하게 만들어주는 구분자입니다. 즉, 도커허브의 퍼블릭이미지를 사용할 때 레포지토리 내부에는 여러 버전의 이미지가 있습니다. 만약 태그를 따로 지정하지 않는다면 도커는 자동으로 ```latest```라는 태그를 붙입니다.
>몇몇 이미지들은 ```{user}```를 붙이지 않는 경우도 있습니다. 예를 들어, ubuntu의 경우 ```canonical/ubuntu```가 아닌 ```ubuntu```만으로도 작동합니다. 이러한 이미지는 공식 이미지이며 기초이미지로는 이러한 공식 이미지를 사용하는 것을 추천합니다.

이미지를 빌드하는데 성공하면, 그 이미지는 도커 서버의 로컬 캐시에 저장되며 나중에 컨테이너를 실행시키는데 사용될 수 있습니다. 또한 이미지를 도커 허브에 푸시할 수도 있습니다.<br/>
```image ls```명령어를 사용하면 캐시된 이미지의 목록을 보여줍니다. 
![Result of docker images ls](/blog/assets/2019-09-21-Docker-2/docker_image_ls.png)<br/><br/>
```docker image ls```명령어의 출력에서는 레포지토리 이름과 태그, 이미지의 ID, 언제 만들어졌으며, 이미지의 크기를 확인할 수 있습니다. 여기서 3개의 허브에서 다운로드한 이미지가 있는 것을 볼 수 있는데, 이 이미지는 Chapter 1에서 다운받았던 이미지입니다. ```kuicsofficial```이라는 user이름으로 만들어진 이미지는 방금 생성한 이미지입니다. 만약 더 큰 이미지를 사용한다면 로컬 캐시는 많은 용량을 차지하게 될 것입니다. 이를 관리하는 법은 Chapter 4에서 다룰 것입니다.
### 2.  도커파일의 명령어
필수적인 도커파일의 명령어는 ```FROM```뿐입니다. ```FROM```은 기초이미지를 지정하는 명령어이며, 도커파일의 최상단에 위치해야 합니다. 물론 ```FROM```만으로는 많은 일을 할 수 없습니다. 아래는 다른 명령어들의 예시입니다.
* ```RUN```: 커맨드를 실행시킵니다.
* ```ENV```: 환경변수를 설정합니다.
* ```COPY```: 파일을 이미지로 복사합니다.
* ```EXPOSE```: 포트를 호스트에 연결할 수 있도록 노출시킵니다.
* ```VOLUME```: 외부 저장장치에 연결될 수 있는 폴더를 이미지 내부에 만듭니다.
* ```CMD```: 컨테이너를 실행시킬 때 실행시킬 명령어를 설정합니다.
이 명령어를 모두 사용한 도커파일을 만들어 보겠습니다. 이 이미지는 특정 포트로부터 입력을 받아 그 정보를 파일로 출력합니다.
```
FROM ubuntu
RUN apt-get update && apt-get install -y netcat-openbsd
ENV LOG_FILE echo.out
COPY ./echoserver.sh /echoserver.sh
RUN chmod +x /echoserver.sh
EXPOSE 8082
VOLUME /server-logs
CMD /echoserver.sh
```

>명령어의 순서는 매우 중요합니다.

echoserver.sh
```
#!/bin/bash

netcat -k -l  -p 8082 > /server-logs/$LOG_FILE
```

도커는 이미지를 빌드하며 아래의 명령을 실행시킵니다.
* 로컬 캐시에 없다면 가장 최근의 우분투 이미지를 다운로드 받습니다.
* 패키지 목록을 업데이트하고 netcat 패키지를 다운로드 받습니다.
* LOG_FILE이라는 환경변수를 echo.out으로 설정합니다.
* echoserver.sh라는 파일을 컨테이너의 루트 폴더에 복사합니다.
* echoserver.sh 파일을 실행가능하도록 권한을 수정합니다.
* 컨테이너의 8082포트를 노출시킵니다.
* server-logs라는 파일시스템을 마운트 시킵니다.

>이러한 명령은 컨테이너 내부에서 이미지를 빌드하며 수행됩니다. 로컬 머신(호스트)가 아닌 이미지 내부에 netcat 패키지와 LOG_FILE 환경변수가 설정되어 있을 것 입니다.

아래는 빌드할 때 명령어를 실행시킨 디렉토리의 파일목록과 빌드 명령어입니다.
![Result of ll and docker image build --tag kuicsofficial/echoserver .](/blog/assets/2019-09-21-Docker-2/docker_image_build_echoserver.png)<br/><br/>

```CMD```명령어를 제외한 나머지 명령어는 이미지를 빌드하며 수행됩니다. 컨테이너를 실행시킬 때 도커는 ```CMD```명령어에 지정된 명령을 실행시킵니다. 위의 이미지는 echoserver.sh라는 스크립트를 실행시킬 것 입니다. echoserver.sh는 netcat을 8082포트로 압력을 받도록 실행시키고 그 출력을 파일로 전달합니다. 파일이 저장되는 위치는 도커파일에 지정된 ```VOLUME```과 환경변수를 이용합니다. ```docker container run --detach --publish 8082:8082 --name echo-server kuicsofficial/echoserver 명령어는 8082포트를 호스트와 연결하여 echoserver이미지를 실행시킵니다.<br/>
아래와 같이 명령어를 실행시키면 호스트에서 8082포트로 문자열을 보냅니다.
![Result of nc localhost 8082](/blog/assets/2019-09-21-Docker-2/nc_local_host_8082.png)<br/><br/>
>윈도우에는 netcat이 없습니다. [netcat](https://eternallybored.org/misc/netcat/)에서 다운로드 받을 수 있습니다.
<br/>
>^C는 <Ctrl-C>입니다.
```docker container exec```명령어를 이용하면 컨테이너 내부에서 명령을 실행한 뒤 출력을 호스트에 보여줍니다. ```docker container exec echo-server cat /server-logs/echo.out```명령어를 사용하여 올바르게 작동했는지 확인해보겠습니다.
![Result of docker container exec echo-server cat /server-logs/echo.out](/blog/assets/2019-09-21-Docker-2/cat_server-logs_echo.out.png)<br/><br/>